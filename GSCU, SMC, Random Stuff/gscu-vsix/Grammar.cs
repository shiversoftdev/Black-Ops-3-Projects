using Irony.Parsing;
using shiversoft.gscuLanguageService;
using System;
using System.Collections.Generic;
using System.Linq;

// NOTE: THIS FILE IS AUTOGENERATED. IF YOU ARE NOT IN GRAMMAR.CS OF GSCU_VSIX, CHANGES WILL BE OVERWRITTEN

namespace shiversoft
{
    [Language("gscu", "1.0", "GSCU Development Extension")]
    public sealed class Grammar : Irony.Parsing.Grammar
    {
        public List<KeyTerm> keywords;
        public readonly KeyTerm kInclude;
        public readonly KeyTerm kNamespace;
        public readonly KeyTerm kClass;
        public readonly KeyTerm kFunction;
        public readonly KeyTerm kPrivate;
        public readonly KeyTerm kAutoexec;
        public readonly KeyTerm kVararg;
        public readonly KeyTerm kReturn;
        public readonly KeyTerm kSize;
        public readonly KeyTerm kTrue;
        public readonly KeyTerm kFalse;
        public readonly KeyTerm kUndefined;
        public readonly KeyTerm kSelf;
        public readonly KeyTerm kWait;
        public readonly KeyTerm kWaitframe;
        public readonly KeyTerm kNotify;
        public readonly KeyTerm kWaittill;
        public readonly KeyTerm kEndon;
        public readonly KeyTerm kIsDefined;
        public readonly KeyTerm kImport;
        public readonly KeyTerm kIf;
        public readonly KeyTerm kElse;
        public readonly KeyTerm kGlobals;
        public readonly KeyTerm kWhile;
        public readonly KeyTerm kVtime;
        public readonly KeyTerm kThread;
        public readonly KeyTerm kBreak;
        public readonly KeyTerm kContinue;
        public readonly KeyTerm kFor;
        public readonly KeyTerm kAs;
        public readonly KeyTerm kIs;
        public readonly KeyTerm kInt;
        public readonly KeyTerm kString;
        public readonly KeyTerm kFloat;
        public readonly KeyTerm kVector;
        public readonly KeyTerm kArray;
        public readonly KeyTerm kStruct;
        public readonly KeyTerm kNot;
        public readonly KeyTerm kDefined;
        public readonly KeyTerm kOr;
        public readonly KeyTerm kAnd;
        public readonly KeyTerm kHash;
        public readonly KeyTerm kTry;
        public readonly KeyTerm kCatch;
        public readonly KeyTerm kDelete;
        public readonly KeyTerm kVar;
        public readonly KeyTerm kConstructor;
        public readonly KeyTerm kDestructor;
        public readonly KeyTerm kGet;
        public readonly KeyTerm kSet;
        public readonly KeyTerm kForeach;
        public readonly KeyTerm kIn;
        public readonly KeyTerm kSwitch;
        public readonly KeyTerm kCase;
        public readonly KeyTerm kDefault;
        public readonly KeyTerm kDebugBreak;
        public readonly KeyTerm kNew;
        public readonly KeyTerm kClasses;
        public readonly KeyTerm kCall;
        public readonly KeyTerm kUnpack;
        public readonly KeyTerm kThrow;

        #region Terminals
        public NumberLiteral NumberLiteral { private set; get; }
        public StringLiteral StringLiteral { private set; get; }
        public IdentifierTerminal NormalIdentifier { private set; get; }
        public IdentifierTerminal FileName { private set; get; }
        #endregion

        #region Directives
        public NonTerminal rootDirectives { private set; get; }
        public NonTerminal rootDirective { private set; get; }
        public NonTerminal directives { private set; get; }
        public NonTerminal directive { private set; get; }
        public NonTerminal usingfile { private set; get; }
        public NonTerminal importApi { private set; get; }
        public NonTerminal nameSpace { private set; get; }
        public NonTerminal classDefinition { private set; get; }
        public NonTerminal functionDefinition { private set; get; }
        public NonTerminal functionModifier { private set; get; }
        public NonTerminal functionModifiers { private set; get; }
        public NonTerminal functionParameters { private set; get; }
        public NonTerminal functionParameter { private set; get; }
        public NonTerminal classDirectives { private set; get; }
        public NonTerminal classDirective { private set; get; }
        public NonTerminal classField { private set; get; }
        public NonTerminal ctor { private set; get; }
        public NonTerminal dtor { private set; get; }
        public NonTerminal classProp { private set; get; }
        public NonTerminal getDec { private set; get; }
        public NonTerminal setDec { private set; get; }
        public NonTerminal classIndexer { private set; get; }
        #endregion

        #region expr
        public NonTerminal booleanExpression { private set; get; }
        public NonTerminal boolExprOperand { private set; get; }
        public NonTerminal expr { private set; get; }
        public NonTerminal parenExpr { private set; get; }
        public NonTerminal mathExpr { private set; get; }
        public NonTerminal parenMathExpr { private set; get; }
        public NonTerminal variableExpr { private set; get; }
        public NonTerminal parenVariableExpr { private set; get; }
        public NonTerminal size { private set; get; }
        public NonTerminal vector { private set; get; }
        public NonTerminal hashedString { private set; get; }
        public NonTerminal hashedVariable { private set; get; }
        public NonTerminal directAccess { private set; get; }
        public NonTerminal getFunction { private set; get; }
        public NonTerminal arrayAccess { private set; get; }
        public NonTerminal boolNot { private set; get; }
        public NonTerminal bitNot { private set; get; }
        public NonTerminal boolNotOperand { private set; get; }
        public NonTerminal booleanAndExpression { private set; get; }
        public NonTerminal booleanOrExpression { private set; get;  }
        public NonTerminal blorOp { private set; get; }
        public NonTerminal parenBooleanExpression { private set; get; }
        public NonTerminal boolOperand { private set; get; }
        public NonTerminal parenBoolOpsExpr { private set; get; }
        public NonTerminal mathOp { private set; get; }
        public NonTerminal pemdas { private set; get; }
        public NonTerminal relationalOperator { private set; get; }
        public NonTerminal relationalExpression { private set; get; }
        public NonTerminal equalityExpression { private set; get; }
        public NonTerminal equalityOperator { private set; get; }
        public NonTerminal ternary { private set; get; }
        public NonTerminal incDec { private set; get; }
        public NonTerminal incDecLocal { private set; get; }
        public NonTerminal stackDeclaration { private set; get; }
        public NonTerminal castTo { private set; get; }
        public NonTerminal varType { private set; get; }
        public NonTerminal checkType { private set; get; }
        public NonTerminal constValue { private set; get; }
        public NonTerminal shortHandArray { private set; get; }
        public NonTerminal arrayAssignments { private set; get; }
        public NonTerminal arrayAssignment { private set; get; }
        public NonTerminal shortHandStruct { private set; get; }
        public NonTerminal structAssignments { private set; get; }
        public NonTerminal incDecField { private set; get; }
        #endregion

        #region function inners
        public NonTerminal blockContent { private set; get; }
        public NonTerminal declarations { private set; get; }
        public NonTerminal declaration { private set; get; }
        public NonTerminal _return { private set; get; }
        public NonTerminal setFieldVariable { private set; get; }
        public NonTerminal setLocalVariable { private set; get; }
        public NonTerminal setArrayField { private set; get; }
        public NonTerminal wait { private set; get; }
        public NonTerminal waitFrame { private set; get; }
        public NonTerminal callParams { private set; get; }
        public NonTerminal notify { private set; get; }
        public NonTerminal endon { private set; get; }
        public NonTerminal waittill { private set; get; }
        public NonTerminal isdefined { private set; get; }
        public NonTerminal waittillStatement { private set; get; }
        public NonTerminal statement { private set; get; }
        public NonTerminal ifStatement { private set; get; }
        public NonTerminal statementBlock { private set; get; }
        public NonTerminal whileStatement { private set; get; }
        public NonTerminal getTime { private set; get; }
        public NonTerminal simpleCall { private set; get; }
        public NonTerminal call { private set; get; }
        public NonTerminal callPrefix { private set; get; }
        public NonTerminal callFrame { private set; get; }
        public NonTerminal baseCall { private set; get; }
        public NonTerminal baseCallPointer { private set; get; }
        public NonTerminal jumpStatement { private set; get; }
        public NonTerminal forStatement { private set; get; }
        public NonTerminal forBody { private set; get; }
        public NonTerminal forIterateEntry { private set; get; }
        public NonTerminal forIterateEntries { private set; get; }
        public NonTerminal incDecStatement { private set; get; }
        public NonTerminal tryStatement { private set; get; }
        public NonTerminal freeStruct { private set; get; }
        public NonTerminal foreachStatement { private set; get; }
        public NonTerminal foreachVars { private set; get; }
        public NonTerminal switchStatement { private set; get; }
        public NonTerminal switchCases { private set; get; }
        public NonTerminal switchCase { private set; get; }
        public NonTerminal switchCaseHeader { private set; get; }
        public NonTerminal debugBreak { private set; get; }
        public NonTerminal classCall { private set; get; }
        public NonTerminal spawnClass { private set; get; }
        public NonTerminal setClassProp { private set; get; }
        public NonTerminal classPropAccessor { private set; get; }
        public NonTerminal unpackToStack { private set; get; }
        public NonTerminal callParam { private set; get; }
        public NonTerminal unpackStatement { private set; get; }
        public NonTerminal unpackList { private set; get; }
        public NonTerminal unpackItem { private set; get; }
        public NonTerminal localFunction { private set; get; }
        public NonTerminal functionCaptures { private set; get; }
        public NonTerminal functionCapturesList { private set; get; }
        public NonTerminal throwException { private set; get; }
        #endregion

        #region misc
        public KeyTerm makeArray { private set; get; }
        public KeyTerm makeStruct { private set; get; }
        public NonTerminal assignmentOperator { private set; get; }
        #endregion

        public Grammar() : base(false)
        {
            #region keywords
            keywords = new List<KeyTerm>();
            RegisterKeyword(ref kInclude, Constants.INCLUDE);
            RegisterKeyword(ref kNamespace, Constants.NAMESPACE);
            RegisterKeyword(ref kClass, Constants.CLASS);
            RegisterKeyword(ref kFunction, Constants.FUNCTION);
            RegisterKeyword(ref kPrivate, Constants.PRIVATE);
            RegisterKeyword(ref kAutoexec, Constants.AUTOEXEC);
            RegisterKeyword(ref kVararg, Constants.VARARG);
            RegisterKeyword(ref kReturn, Constants.RETURN);
            RegisterKeyword(ref kSize, Constants.SIZE);
            RegisterKeyword(ref kTrue, Constants.TRUE);
            RegisterKeyword(ref kFalse, Constants.FALSE);
            RegisterKeyword(ref kUndefined, Constants.UNDEFINED);
            RegisterKeyword(ref kSelf, Constants.SELF);
            RegisterKeyword(ref kWait, Constants.WAIT);
            RegisterKeyword(ref kWaitframe, Constants.WAITFRAME);
            RegisterKeyword(ref kNotify, Constants.NOTIFY);
            RegisterKeyword(ref kEndon, Constants.ENDON);
            RegisterKeyword(ref kWaittill, Constants.WAITTILL);
            RegisterKeyword(ref kIsDefined, Constants.ISDEFINED);
            RegisterKeyword(ref kImport, Constants.IMPORT);
            RegisterKeyword(ref kIf, Constants.IF);
            RegisterKeyword(ref kElse, Constants.ELSE);
            RegisterKeyword(ref kGlobals, Constants.GLOBALS);
            RegisterKeyword(ref kWhile, Constants.WHILE);
            RegisterKeyword(ref kVtime, Constants.VTIME);
            RegisterKeyword(ref kThread, Constants.THREAD);
            RegisterKeyword(ref kBreak, Constants.BREAK);
            RegisterKeyword(ref kContinue, Constants.CONTINUE);
            RegisterKeyword(ref kFor, Constants.FOR);
            RegisterKeyword(ref kAs, Constants.AS);
            RegisterKeyword(ref kIs, Constants.IS);
            RegisterKeyword(ref kInt, Constants.INT);
            RegisterKeyword(ref kString, Constants.STRING);
            RegisterKeyword(ref kFloat, Constants.FLOAT);
            RegisterKeyword(ref kVector, Constants.VECTOR);
            RegisterKeyword(ref kArray, Constants.ARRAY);
            RegisterKeyword(ref kStruct, Constants.STRUCT);
            RegisterKeyword(ref kNot, Constants.NOT);
            RegisterKeyword(ref kDefined, Constants.DEFINED);
            RegisterKeyword(ref kAnd, Constants.AND);
            RegisterKeyword(ref kOr, Constants.OR);
            RegisterKeyword(ref kHash, Constants.HASH);
            RegisterKeyword(ref kTry, Constants.TRY);
            RegisterKeyword(ref kCatch, Constants.CATCH);
            RegisterKeyword(ref kDelete, Constants.DELETE);
            RegisterKeyword(ref kVar, Constants.VAR);
            RegisterKeyword(ref kConstructor, Constants.CONSTRUCTOR);
            RegisterKeyword(ref kDestructor, Constants.DESTRUCTOR);
            RegisterKeyword(ref kGet, Constants.GET);
            RegisterKeyword(ref kSet, Constants.SET);
            RegisterKeyword(ref kForeach, Constants.FOREACH);
            RegisterKeyword(ref kIn, Constants.IN);
            RegisterKeyword(ref kSwitch, Constants.SWITCH);
            RegisterKeyword(ref kCase, Constants.CASE);
            RegisterKeyword(ref kDefault, Constants.DEFAULT);
            RegisterKeyword(ref kDebugBreak, Constants.DEBUGBREAK);
            RegisterKeyword(ref kNew, Constants.NEW);
            RegisterKeyword(ref kClasses, Constants.CLASSES);
            RegisterKeyword(ref kCall, Constants.CALL);
            RegisterKeyword(ref kUnpack, Constants.UNPACK);
            RegisterKeyword(ref kThrow, Constants.THROW);

            makeArray = new KeyTerm(Constants.NEWARRAY, Constants.NEWARRAY);
            makeStruct = new KeyTerm(Constants.NEWSTRUCT, Constants.NEWSTRUCT);
            #endregion

            #region Operators
            //Punctuation
            MarkPunctuation("(", ")", "{", "}", "[", "]", ",", ".", ".(", ";", "::", "[[", "]]", "->", "#", "?", ":", "~", "@", "=>");

            //Operators
            RegisterOperators(0, "=", "+=", "-=", "*=", "/=", "%=", "|=", "&=", "^=", "<<=", ">>=", "??=");
            RegisterOperators(1, "||");
            RegisterOperators(2, "&&");
            RegisterOperators(3, "|");
            RegisterOperators(4, "^");
            RegisterOperators(5, "&");
            RegisterOperators(6, "==", "!=");
            RegisterOperators(7, "<", ">", "<=", ">=");
            RegisterOperators(8, "+", "-");
            RegisterOperators(9, "*", "/", "%");

            RegisterBracePair("{", "}");
            RegisterBracePair("(", ")");

            MarkMemberSelect(".", "::");
            #endregion

            #region Terminals
            //Literals
            NumberLiteral = TerminalFactory.CreateCSharpNumber(Constants.NUMBERLITERAL);
            NumberLiteral.Options = NumberOptions.AllowSign;
            NormalIdentifier = Identifier(Constants.IDENTIFIER, false);
            FileName = Identifier(Constants.FILENAME, true);
            StringLiteral = new StringLiteral(Constants.STRINGLITERAL, "\"", StringOptions.AllowsAllEscapes);

            //Comments
            NonGrammarTerminals.Add(new CommentTerminal("block-comment", "/*", "*/"));
            NonGrammarTerminals.Add(new CommentTerminal("line-comment", "//", "\r", "\n", "\u2085", "\u2028", "\u2029"));
            #endregion

            CreateNonTerminals();

            #region Directives
            //Master Directive Rules
            rootDirectives.Rule = MakeStarRule(rootDirectives, null, rootDirective);
            rootDirective.Rule = usingfile | importApi | nameSpace | classDefinition;
            directives.Rule = MakeStarRule(directives, null, directive);
            directive.Rule = functionDefinition;
            classDirectives.Rule = MakeStarRule(classDirectives, null, classDirective);
            classDirective.Rule = functionDefinition | classField | ctor | dtor /*| classIndexer*/ | classProp;
            classField.Rule = kVar + NormalIdentifier + ";" | kVar + NormalIdentifier + "=" + constValue + ";";
            ctor.Rule = kConstructor + "(" + functionParameters + ")" + blockContent;
            dtor.Rule = kDestructor + "(" + functionParameters + ")" + blockContent;
            classProp.Rule = kVar + NormalIdentifier + "{" + getDec + setDec + "}" + ";" | kVar + NormalIdentifier + "{" + setDec + getDec + "}" + ";";
            getDec.Rule = kGet + "(" + functionParameters + ")" + blockContent | kGet + ";";
            setDec.Rule = kSet + "(" + functionParameters + ")" + blockContent | kSet + ";";
            classIndexer.Rule = kSelf + "[" + "]" + "{" + getDec + setDec + "}" + ";" | kSelf + "[" + "]" + "{" + getDec + setDec + "}" + ";";

            usingfile.Rule = kInclude + FileName + ";";
            importApi.Rule = kImport + FileName + ";";
            nameSpace.Rule = kNamespace + NormalIdentifier + "{" + directives + "}";
            classDefinition.Rule = kClass + NormalIdentifier + "{" + classDirectives + "}";

            functionParameter.Rule = NormalIdentifier | ToTerm(Constants.VADECLARATION) | setLocalVariable;
            functionParameters.Rule = MakeStarRule(functionParameters, ToTerm(","), functionParameter);
            functionModifier.Rule = kPrivate | kAutoexec;
            functionModifiers.Rule = MakeStarRule(functionModifiers, null, functionModifier);
            functionDefinition.Rule = kFunction + functionModifiers + NormalIdentifier + "(" + functionParameters + ")" + blockContent;
            #endregion

            #region expr
            // master expressions
            expr.Rule = parenExpr | mathExpr | makeArray | makeStruct | shortHandArray | shortHandStruct | boolNot | bitNot;
            mathExpr.Rule = parenMathExpr | variableExpr | StringLiteral | NumberLiteral | kTrue | kFalse | kUndefined | size | hashedString | hashedVariable | vector | getTime;
            variableExpr.Rule = parenVariableExpr | directAccess | call | classCall | spawnClass | NormalIdentifier | kVararg |  kSelf | kGlobals | getFunction | localFunction | waittill | isdefined | arrayAccess | checkType | stackDeclaration | incDec | castTo;

            constValue.Rule = StringLiteral | makeArray | makeStruct | NumberLiteral | kTrue | kFalse | kUndefined | hashedString | hashedVariable | kGlobals | kSelf | getFunction;

            booleanExpression.Rule = boolExprOperand | booleanAndExpression | booleanOrExpression;
            boolExprOperand.Rule = expr | boolOperand | parenBooleanExpression | parenBoolOpsExpr;
            boolNot.Rule = ToTerm("!") + boolNotOperand | kNot + boolNotOperand;
            bitNot.Rule = ToTerm("~") + boolNotOperand;
            boolNotOperand.Rule = expr | parenBooleanExpression | parenBoolOpsExpr;
            booleanAndExpression.Rule = booleanExpression + ToTerm("&&") + booleanExpression | booleanExpression + kAnd + booleanExpression;
            booleanOrExpression.Rule = blorOp + ToTerm("||") + blorOp | blorOp + kOr + blorOp | booleanExpression + ToTerm("||") + booleanExpression | booleanExpression + kOr + booleanExpression;
            blorOp.Rule = booleanAndExpression | boolExprOperand;
            boolOperand.Rule = pemdas | relationalExpression | equalityExpression | ternary;
            pemdas.Rule = boolExprOperand + mathOp + boolExprOperand;
            relationalExpression.Rule = boolExprOperand + relationalOperator + boolExprOperand;
            equalityExpression.Rule = boolExprOperand + equalityOperator + boolExprOperand;
            ternary.Rule = booleanExpression + ToTerm("?") + booleanExpression + ToTerm(":") + booleanExpression;
            
            arrayAssignments.Rule = MakePlusRule(arrayAssignments, ToTerm(","), booleanExpression);
            shortHandArray.Rule = "[" + arrayAssignments + "]";

            structAssignments.Rule = MakePlusRule(structAssignments, ToTerm(","), setLocalVariable);
            shortHandStruct.Rule = "{" + structAssignments + "}";

            directAccess.Rule = variableExpr + "." + NormalIdentifier;
            arrayAccess.Rule = variableExpr + "[" + booleanExpression + "]";
            unpackToStack.Rule = kUnpack + booleanExpression;
            unpackItem.Rule = NormalIdentifier | directAccess | arrayAccess;
            unpackList.Rule = MakePlusRule(unpackList, ToTerm(","), unpackItem);
            unpackStatement.Rule = unpackList + ":" + kUnpack + booleanExpression;

            // parenthesis
            parenExpr.Rule = "(" + expr + ")";
            parenMathExpr.Rule = "(" + mathExpr + ")";
            parenVariableExpr.Rule = "(" + variableExpr + ")";
            parenBooleanExpression.Rule = "(" + booleanExpression + ")";
            parenBoolOpsExpr.Rule = "(" + booleanAndExpression + ")" | "(" + booleanOrExpression + ")";

            size.Rule = variableExpr + ToTerm(".") + kSize | StringLiteral + ToTerm(".") + kSize | vector + ToTerm(".") + kSize;
            vector.Rule = "(" + booleanExpression + "," + booleanExpression + "," + booleanExpression + "," + booleanExpression + ")" |
                          "(" + booleanExpression + "," + booleanExpression + "," + booleanExpression + ")" |
                          "(" + booleanExpression + "," + booleanExpression + ")";

            hashedString.Rule = ToTerm("#") + StringLiteral;
            hashedVariable.Rule = ToTerm("#") + NormalIdentifier;

            assignmentOperator.Rule = ToTerm("=") | "+=" | "-=" | "*=" | "/=" | "%=" | "|=" | "&=" | "^=" /*| "??="*/ | "<<=" | ">>=";
            mathOp.Rule = ToTerm("*") | "/" | "%" | "+" | "-" | "&" | "^" | "|" | "<<" | ">>" /*| "??"*/;
            relationalOperator.Rule = ToTerm(">") | ">=" | "<" | "<=";
            equalityOperator.Rule = ToTerm("==") | "!=" | "===" | "!==";
            getFunction.Rule = ToTerm("&") + NormalIdentifier + "::" + NormalIdentifier | ToTerm("&") + NormalIdentifier;
            #endregion

            #region function inners
            declarations.Rule = MakeStarRule(declarations, declaration);
            declaration.Rule = _return | throwException + ";" | unpackStatement + ";" | incDecStatement | setClassProp + ";" | setLocalVariable + ";" | setFieldVariable + ";" | setArrayField + ";" | wait + ";" | waitFrame + ";" | notify + ";" | endon + ";" | waittillStatement | statement | simpleCall | jumpStatement | freeStruct | debugBreak;
            stackDeclaration.Rule = setLocalVariable | setFieldVariable | setArrayField;
            blockContent.Rule = ToTerm("{") + declarations + ToTerm("}");

            _return.Rule = kReturn + booleanExpression + ";" | kReturn + makeArray + ";" | kReturn + makeStruct + ";" | kReturn + ";";
            setLocalVariable.Rule = NormalIdentifier + assignmentOperator + booleanExpression;
            setFieldVariable.Rule = directAccess + assignmentOperator + booleanExpression;
            setArrayField.Rule = arrayAccess + assignmentOperator + booleanExpression;
            wait.Rule = kWait + booleanExpression;
            waitFrame.Rule = kWaitframe + booleanExpression;
            callParam.Rule = booleanExpression | unpackToStack;
            callParams.Rule = MakeStarRule(callParams, ToTerm(","), callParam);
            notify.Rule = variableExpr + kNotify + "(" + callParams + ")";
            endon.Rule = variableExpr + kEndon + "(" + callParams + ")";
            waittill.Rule = variableExpr + kWaittill + "(" + callParams + ")";
            waittillStatement.Rule = waittill + ";";
            isdefined.Rule = kIsDefined + "(" + expr + ")";
            freeStruct.Rule = kDelete + variableExpr + ";";
            debugBreak.Rule = kDebugBreak + "(" + ")" + ";";
            classPropAccessor.Rule = ":" + kSet | ":" + kGet | ":" + kCall;
            setClassProp.Rule = kClasses + "[" + booleanExpression + "]" + "[" + booleanExpression + "]" + classPropAccessor + "=" + booleanExpression |
                                kClasses + "[" + booleanExpression + "]" + "." + NormalIdentifier + classPropAccessor + "=" + booleanExpression |
                                kClasses + "." + NormalIdentifier + "[" + booleanExpression + "]" + classPropAccessor + "=" + booleanExpression |
                                kClasses + "." + NormalIdentifier + "." + NormalIdentifier + classPropAccessor + "=" + booleanExpression;

            // statement master rule
            statement.Rule = ifStatement | whileStatement | forStatement | tryStatement | switchStatement | foreachStatement;

            ifStatement.Rule = kIf + "(" + booleanExpression + ")" + statementBlock + kElse + statementBlock | kIf + "(" + booleanExpression + ")" + statementBlock;
            statementBlock.Rule = blockContent | declaration;

            whileStatement.Rule = kWhile + "(" + booleanExpression + ")" + statementBlock;
            getTime.Rule = kVtime + "(" + ")";

            tryStatement.Rule = kTry + statementBlock + kCatch + "(" + NormalIdentifier + ")" + statementBlock;

            foreachStatement.Rule = 
                kForeach + "(" + foreachVars + kIn + variableExpr + ")" + statementBlock |
                kForeach + "(" + foreachVars + kIn + shortHandArray + ")" + statementBlock |
                kForeach + "(" + foreachVars + kIn + shortHandStruct + ")" + statementBlock;
            foreachVars.Rule = NormalIdentifier + "," + NormalIdentifier | NormalIdentifier;

            switchStatement.Rule = kSwitch + "(" + expr + ")" + "{" + switchCases + "}";
            switchCases.Rule = MakeStarRule(switchCases, null, switchCase);
            switchCase.Rule = switchCaseHeader + statementBlock | switchCaseHeader + declarations | switchCaseHeader;
            switchCaseHeader.Rule = kCase + StringLiteral + ":" | kCase + NumberLiteral + ":" | kCase + kTrue + ":" | kCase + kFalse + ":" | kDefault + ":";

            functionCapturesList.Rule = MakeStarRule(functionCapturesList, ToTerm(","), NormalIdentifier);
            functionCaptures.Rule = "<" + functionCapturesList + ">";
            localFunction.Rule = kFunction + functionCaptures + "(" + functionParameters + ")" + "=>" + blockContent | kFunction + "(" + functionParameters + ")" + "=>" + blockContent;

            throwException.Rule = kThrow + "(" + booleanExpression + "," + booleanExpression  + "," + booleanExpression + ")";

            // calls
            simpleCall.Rule = call + ";" | classCall + ";" | spawnClass + ";";
            call.Rule = callPrefix + callFrame | kThread + callFrame | callFrame;
            classCall.Rule = variableExpr + "->" + NormalIdentifier + "(" + callParams + ")" |
                             kThread + variableExpr + "->" + NormalIdentifier + "(" + callParams + ")";
            spawnClass.Rule = kNew + NormalIdentifier + "(" + callParams + ")";
            callPrefix.Rule = variableExpr + kThread | variableExpr;
            callFrame.Rule = baseCall | baseCallPointer;
            baseCall.Rule = NormalIdentifier + "::" + NormalIdentifier + "(" + callParams + ")" | NormalIdentifier + "(" + callParams + ")";
            baseCallPointer.Rule = ToTerm("[" + "[") + variableExpr + "]" + "]" + "(" + callParams + ")";

            //Loop Control
            jumpStatement.Rule = kBreak + ";" | kBreak + NumberLiteral + ";" | kContinue + ";" | kContinue + NumberLiteral + ";";

            //For Loop
            forStatement.Rule = kFor + "(" + forBody + ")" + statementBlock;
            forIterateEntry.Rule = setLocalVariable | setFieldVariable | setArrayField | wait | waitFrame | notify | waittill | call | incDec | classCall;
            forIterateEntries.Rule = MakeStarRule(forIterateEntries, ToTerm(","), forIterateEntry);
            forBody.Rule = forIterateEntries + ";" + booleanExpression + ";" + forIterateEntries
                           | forIterateEntries + ";" + ";" + forIterateEntries;

            incDecLocal.Rule = ToTerm("++") + NormalIdentifier | NormalIdentifier + ToTerm("++") | NormalIdentifier + ToTerm("--") | ToTerm("--") + NormalIdentifier;
            // incDecArray.Rule = ToTerm("++") + arrayAccess | ToTerm("--") + arrayAccess | arrayAccess + "++" | arrayAccess + "--";
            incDecField.Rule = ToTerm("++") + directAccess | ToTerm("--") + directAccess | directAccess + "--" | directAccess + "++";
            incDec.Rule = incDecLocal | incDecField /*| incDecArray*/;
            incDecStatement.Rule = incDec + ";";
            castTo.Rule = booleanExpression + kAs + varType;
            checkType.Rule = booleanExpression + kIs + varType 
                | booleanExpression + kIs + kUndefined 
                | booleanExpression + kIs + kNot + varType 
                | booleanExpression + kIs + kNot + kUndefined 
                | booleanExpression + kIs + kDefined 
                | booleanExpression + kIs + kNot + kDefined;

            varType.Rule = kInt | kString | kHash | kFloat | kVector | kFunction | kArray | kStruct;
            #endregion

            // TODO: macros, headers (#insert), ifdef, ifndef, else, else if, endif
            // TODO: unary operators: ++, -- (fields and arrays)
            // TODO: goto, labels (remember safe context monitoring)
            // TODO: anon funcs (captures only)
            // TODO: undefined coalescent operators
            // TODO: try-catch (only issue right now is dropping safe context when jumps exit range)
            // TODO: runtime class changes classes.c.prop:set,classes.c.prop:get, classes.c.prop:method
            // TODO: fix destructors in the vm and compiler because current methodology is not going to work correctly when variables are freed
            //       idea: maybe schedule a thread that only executes a destructor and frees itself?

            // TODO: eventually, custom indexers

            MarkTransient(rootDirective, directive, functionModifier, declaration,
                blockContent, parenExpr, parenMathExpr, parenVariableExpr,
                assignmentOperator, mathExpr, variableExpr, expr,
                boolExprOperand, booleanExpression, statement, statementBlock,
                boolNotOperand, blorOp, parenBooleanExpression, boolOperand, parenBoolOpsExpr, mathOp,
                relationalOperator, equalityOperator, forIterateEntry, incDec, varType,
                classDirective, constValue, callParam, unpackItem);
        }

        private void RegisterKeyword(ref KeyTerm term, string tStringVal)
        {
            tStringVal = tStringVal.ToLower();
            term = ToTerm(tStringVal);
            term.EditorInfo = new TokenEditorInfo(TokenType.Keyword, TokenColor.Keyword, TokenTriggers.None);
            keywords.Add(term);
            MarkReservedWords(tStringVal);
        }

        private IdentifierTerminal Identifier(string name, bool filename)
        {
            IdentifierTerminal identifierTerminal = (IdentifierTerminal)new GscuIdentifierTerminal(name, filename);
            TokenColor color = filename ? TokenColor.String : TokenColor.Identifier;
            identifierTerminal.EditorInfo = new TokenEditorInfo(TokenType.Identifier, color, filename ? TokenTriggers.MemberSelect : TokenTriggers.None);
            return identifierTerminal;
        }

        public static class Constants
        {
            public const string INCLUDE = "#include";
            public const string NAMESPACE = "namespace";
            public const string CLASS = "class";
            public const string FUNCTION = "function";
            public const string PRIVATE = "private";
            public const string AUTOEXEC = "autoexec";
            public const string NUMBERLITERAL = "numberliteral";
            public const string IDENTIFIER = "identifier";
            public const string FILENAME = "filename";
            public const string STRINGLITERAL = "stringliteral";
            public const string ROOTDIRECTIVES = "rootdirectives";
            public const string ROOTDIRECTIVE = "rootdirective";
            public const string DIRECTIVES = "directives";
            public const string DIRECTIVE = "directive";
            public const string USINGFILE = "usingfile";
            public const string FUNCTIONMODIFIER = "functionmodifier";
            public const string FUNCTIONMODIFIERS = "functionmodifiers";
            public const string FUNCTIONPARAMETERS = "functionparameters";
            public const string FUNCTIONPARAMETER = "functionparameter";
            public const string BLOCKCONTENT = "blockcontent";
            public const string VARARG = "vararg";
            public const string DECLARATIONS = "declarations";
            public const string DECLARATION = "declaration";
            public const string RETURN = "return";
            public const string NEWARRAY = "[]";
            public const string BOOLEANEXPRESSION = "booleanexpression";
            public const string BOOLEXPROPERAND = "boolexproperand";
            public const string EXPR = "expr";
            public const string PARENEXPR = "parenexpr";
            public const string MATHEXPR = "mathexpr";
            public const string PARENMATHEXPR = "parenmathexpr";
            public const string VARIABLEEXPR = "variableexpr";
            public const string PARENVARIABLEEXPR = "parenvariableexpr";
            public const string SIZE = "size";
            public const string VEC = "vec";
            public const string VECTOR = "vector";
            public const string HASHEDSTRING = "hashedstring";
            public const string HASHEDVARIABLE = "hashedvariable";
            public const string SETLOCALVARIABLE = "setlocalvariable";
            public const string ASSIGNMENTOPERATOR = "assignmentoperator";
            public const string TRUE = "true";
            public const string FALSE = "false";
            public const string UNDEFINED = "undefined";
            public const string SELF = "self";
            public const string NEWSTRUCT = "{}";
            public const string DIRECTACCESS = "directaccess";
            public const string SETFIELDVARIABLE = "setfieldvariable";
            public const string GETFUNCTION = "getfunction";
            public const string WAIT = "wait";
            public const string WAITFRAME = "waitframe";
            public const string WAITTILL = "waittill";
            public const string NOTIFY = "notify";
            public const string ENDON = "endon";
            public const string CALLPARAMS = "callparams";
            public const string ISDEFINED = "isdefined";
            public const string WAITTILLSTATEMENT = "waittillstatement";
            public const string IMPORT = "#import";
            public const string IMPORTAPI = "importapi";
            public const string STATEMENT = "statement";
            public const string IFSTATEMENT = "ifstatement";
            public const string IF = "if";
            public const string STATEMENTBLOCK = "statementblock";
            public const string ELSE = "else";
            public const string LEVEL = "level";
            public const string WHILE = "while";
            public const string WHILESTATEMENT = "whilestatement";
            public const string VTIME = "vtime";
            public const string ARRAYACCESS = "arrayaccess";
            public const string SETARRAYFIELD = "setarrayfield";
            public const string BOOLNOT = "boolnot";
            public const string BOOLNOTOPERAND = "boolnotoperand";
            public const string BOOLEANANDEXPRESSION = "booleanandexpression";
            public const string BOOLEANOREXPRESSION = "booleanorexpression";
            public const string BLOROP = "blorop";
            public const string PARENBOOLEXPR = "parenboolexpr";
            public const string BOOLOPERAND = "booloperand";
            public const string PARENBOOLOPSEXPR = "parenboolopsexpr";
            public const string MATHOP = "mathop";
            public const string PEMDAS = "pemdas";
            public const string RELATIONALOPERATOR = "relationaloperator";
            public const string RELATIONALEXPRESSION = "relationalexpression";
            public const string EQUALITYEXPRESSION = "equalityexpression";
            public const string EQUALITYOPERATOR = "equalityoperator";
            public const string TERNARY = "ternary";
            public const string SIMPLECALL = "simplecall";
            public const string CALL = "call";
            public const string THREAD = "thread";
            public const string CALLPREFIX = "callprefix";
            public const string CALLFRAME = "callframe";
            public const string BASECALL = "basecall";
            public const string BASECALLPOINTER = "basecallpointer";
            public const string CONTINUE = "continue";
            public const string BREAK = "break";
            public const string JUMPSTATEMENT = "jumpstatement";
            public const string FOR = "for";
            public const string FORSTATEMENT = "forstatement";
            public const string FORBODY = "forbody";
            public const string FORITERATEENTRY = "foriterateentry";
            public const string FORITERATEENTRIES = "foriterateentries";
            public const string INCDEC = "incdec";
            public const string INCDECLOCAL = "incdeclocal";
            public const string STACKDECLARATION = "stackdeclaration";
            public const string BITNOT = "bitnot";
            public const string IS = "is";
            public const string AS = "as";
            public const string INCDECSTATEMENT = "incdecstatement";
            public const string INT = "int";
            public const string STRING = "string";
            public const string FLOAT = "float";
            public const string STRUCT = "struct";
            public const string ARRAY = "array";
            public const string CASTTO = "castto";
            public const string VARTYPE = "vartype";
            public const string CHECKTYPE = "checktype";
            public const string NOT = "not";
            public const string DEFINED = "defined";
            public const string AND = "and";
            public const string OR = "or";
            public const string HASH = "hash";
            public const string TRYSTATEMENT = "trystatement";
            public const string TRY = "try";
            public const string CATCH = "catch";
            public const string DELETE = "delete";
            public const string FREESTRUCT = "freestruct";
            public const string CLASSDIRECTIVES = "classdirectives";
            public const string CLASSDIRECTIVE = "classdirective";
            public const string VAR = "var";
            public const string CLASSFIELD = "classfield";
            public const string CONSTVALUE = "constvalue";
            public const string CTOR = "ctor";
            public const string CONSTRUCTOR = "constructor";
            public const string DTOR = "dtor";
            public const string DESTRUCTOR = "destructor";
            public const string CLASSPROP = "classprop";
            public const string GETDEC = "getdec";
            public const string SETDEC = "setdec";
            public const string GET = "get";
            public const string SET = "set";
            public const string CLASSINDEXER = "classindexer";
            public const string FOREACHSTATEMENT = "foreachstatement";
            public const string FOREACH = "foreach";
            public const string IN = "in";
            public const string FOREACHVARS = "foreachvars";
            public const string SWITCHSTATEMENT = "switchstatement";
            public const string SWITCH = "switch";
            public const string CASE = "case";
            public const string DEFAULT = "default";
            public const string SWITCHCASES = "switchcases";
            public const string SWITCHCASE = "switchcase";
            public const string SWITCHCASEHEADER = "switchcaseheader";
            public const string SHORTHANDARRAY = "shorthandarray";
            public const string ARRAYASSIGNMENTS = "arrayassignments";
            public const string ARRAYASSIGNMENT = "arrayassignment";
            public const string SHORTHANDSTRUCT = "shorthandstruct";
            public const string STRUCTASSIGNMENTS = "structassignments";
            public const string INCDECFIELD = "incdecfield";
            public const string INCDECARRAY = "incdecarray";
            public const string DEBUGBREAK = "__debugbreak";
            public const string CLASSCALL = "classcall";
            public const string NEW = "new";
            public const string SPAWNCLASS = "spawnclass";
            public const string CLASSES = "classes";
            public const string SETCLASSPROP = "setclassprop";
            public const string CLASSPROPSETTER = "classpropsetter";
            public const string VADECLARATION = "...";
            public const string UNPACK = "unpack";
            public const string UNPACKTOSTACK = "unpacktostack";
            public const string CALLPARAM = "callparam";
            public const string UNPACKSTATEMENT = "unpackstatement";
            public const string UNPACKLIST = "unpacklist";
            public const string UNPACKITEM = "unpackitem";
            public const string CROSS = "cross";
            public const string DOT = "dot";
            public const string VECOP = "vecop";
            public const string LOCALFUNCTION = "localfunction";
            public const string FUNCTIONCAPTURES = "functioncaptures";
            public const string FUNCTIONCAPLIST = "functioncaplist";
            public const string FUNCTIONCAPTURE = "functioncapture";
            public const string THROW = "throw";
            public const string THROWEXCEPTION = "throwexception";
            public const string GLOBALS = "globals";
        }

        private void CreateNonTerminals()
        {
            rootDirectives = new NonTerminal(Constants.ROOTDIRECTIVES);
            rootDirective = new NonTerminal(Constants.ROOTDIRECTIVE);
            directives = new NonTerminal(Constants.DIRECTIVES);
            directive = new NonTerminal(Constants.DIRECTIVE);
            usingfile = new NonTerminal(Constants.USINGFILE);
            importApi = new NonTerminal(Constants.IMPORTAPI);
            nameSpace = new NonTerminal(Constants.NAMESPACE);
            classDefinition = new NonTerminal(Constants.CLASS);
            functionDefinition = new NonTerminal(Constants.FUNCTION);
            functionModifier = new NonTerminal(Constants.FUNCTIONMODIFIER);
            functionModifiers = new NonTerminal(Constants.FUNCTIONMODIFIERS);
            functionParameters = new NonTerminal(Constants.FUNCTIONPARAMETERS);
            functionParameter = new NonTerminal(Constants.FUNCTIONPARAMETER);
            booleanExpression = new NonTerminal(Constants.BOOLEANEXPRESSION);
            boolExprOperand = new NonTerminal(Constants.BOOLEXPROPERAND);
            expr = new NonTerminal(Constants.EXPR);
            parenExpr = new NonTerminal(Constants.PARENEXPR);
            mathExpr = new NonTerminal(Constants.MATHEXPR);
            parenMathExpr = new NonTerminal(Constants.PARENMATHEXPR);
            variableExpr = new NonTerminal(Constants.VARIABLEEXPR);
            parenVariableExpr = new NonTerminal(Constants.PARENVARIABLEEXPR);
            size = new NonTerminal(Constants.SIZE);
            vector = new NonTerminal(Constants.VEC);
            hashedString = new NonTerminal(Constants.HASHEDSTRING);
            hashedVariable = new NonTerminal(Constants.HASHEDVARIABLE);
            setLocalVariable = new NonTerminal(Constants.SETLOCALVARIABLE);
            assignmentOperator = new NonTerminal(Constants.ASSIGNMENTOPERATOR);
            directAccess = new NonTerminal(Constants.DIRECTACCESS);
            setFieldVariable = new NonTerminal(Constants.SETFIELDVARIABLE);
            getFunction = new NonTerminal(Constants.GETFUNCTION);
            wait = new NonTerminal(Constants.WAIT);
            waitFrame = new NonTerminal(Constants.WAITFRAME);
            callParams = new NonTerminal(Constants.CALLPARAMS);
            notify = new NonTerminal(Constants.NOTIFY);
            endon = new NonTerminal(Constants.ENDON);
            waittill = new NonTerminal(Constants.WAITTILL);
            isdefined = new NonTerminal(Constants.ISDEFINED);
            waittillStatement = new NonTerminal(Constants.WAITTILLSTATEMENT);
            statement = new NonTerminal(Constants.STATEMENT);
            ifStatement = new NonTerminal(Constants.IFSTATEMENT);
            statementBlock = new NonTerminal(Constants.STATEMENTBLOCK);
            whileStatement = new NonTerminal(Constants.WHILESTATEMENT);
            getTime = new NonTerminal(Constants.VTIME);
            arrayAccess = new NonTerminal(Constants.ARRAYACCESS);
            setArrayField = new NonTerminal(Constants.SETARRAYFIELD);
            boolNot = new NonTerminal(Constants.BOOLNOT);
            bitNot = new NonTerminal(Constants.BITNOT);
            boolNotOperand = new NonTerminal(Constants.BOOLNOTOPERAND);
            booleanAndExpression = new NonTerminal(Constants.BOOLEANANDEXPRESSION);
            booleanOrExpression = new NonTerminal(Constants.BOOLEANOREXPRESSION);
            blorOp = new NonTerminal(Constants.BLOROP);
            parenBooleanExpression = new NonTerminal(Constants.PARENBOOLEXPR);
            boolOperand = new NonTerminal(Constants.BOOLOPERAND);
            parenBoolOpsExpr = new NonTerminal(Constants.PARENBOOLOPSEXPR);
            mathOp = new NonTerminal(Constants.MATHOP);
            pemdas = new NonTerminal(Constants.PEMDAS);
            relationalOperator = new NonTerminal(Constants.RELATIONALOPERATOR);
            relationalExpression = new NonTerminal(Constants.RELATIONALEXPRESSION);
            equalityExpression = new NonTerminal(Constants.EQUALITYEXPRESSION);
            equalityOperator = new NonTerminal(Constants.EQUALITYOPERATOR);
            ternary = new NonTerminal(Constants.TERNARY);
            simpleCall = new NonTerminal(Constants.SIMPLECALL);
            call = new NonTerminal(Constants.CALL);
            callPrefix = new NonTerminal(Constants.CALLPREFIX);
            callFrame = new NonTerminal(Constants.CALLFRAME);
            baseCall = new NonTerminal(Constants.BASECALL);
            baseCallPointer = new NonTerminal(Constants.BASECALLPOINTER);
            jumpStatement = new NonTerminal(Constants.JUMPSTATEMENT);
            forStatement = new NonTerminal(Constants.FORSTATEMENT);
            forBody = new NonTerminal(Constants.FORBODY);
            forIterateEntry = new NonTerminal(Constants.FORITERATEENTRY);
            forIterateEntries = new NonTerminal(Constants.FORITERATEENTRIES);
            incDec = new NonTerminal(Constants.INCDEC);
            incDecLocal = new NonTerminal(Constants.INCDECLOCAL);
            stackDeclaration = new NonTerminal(Constants.STACKDECLARATION);
            incDecStatement = new NonTerminal(Constants.INCDECSTATEMENT);
            castTo = new NonTerminal(Constants.CASTTO);
            varType = new NonTerminal(Constants.VARTYPE);
            checkType = new NonTerminal(Constants.CHECKTYPE);
            tryStatement = new NonTerminal(Constants.TRYSTATEMENT);
            freeStruct = new NonTerminal(Constants.FREESTRUCT);
            classDirectives = new NonTerminal(Constants.CLASSDIRECTIVES);
            classDirective = new NonTerminal(Constants.CLASSDIRECTIVE);
            classField = new NonTerminal(Constants.CLASSFIELD);
            constValue = new NonTerminal(Constants.CONSTVALUE);
            ctor = new NonTerminal(Constants.CTOR);
            dtor = new NonTerminal(Constants.DTOR);
            classProp = new NonTerminal(Constants.CLASSPROP);
            getDec = new NonTerminal(Constants.GETDEC);
            setDec = new NonTerminal(Constants.SETDEC);
            classIndexer = new NonTerminal(Constants.CLASSINDEXER);
            foreachStatement = new NonTerminal(Constants.FOREACHSTATEMENT);
            foreachVars = new NonTerminal(Constants.FOREACHVARS);
            switchStatement = new NonTerminal(Constants.SWITCHSTATEMENT);
            switchCases = new NonTerminal(Constants.SWITCHCASES);
            switchCase = new NonTerminal(Constants.SWITCHCASE);
            switchCaseHeader = new NonTerminal(Constants.SWITCHCASEHEADER);
            debugBreak = new NonTerminal(Constants.DEBUGBREAK);
            classCall = new NonTerminal(Constants.CLASSCALL);
            spawnClass = new NonTerminal(Constants.SPAWNCLASS);
            setClassProp = new NonTerminal(Constants.SETCLASSPROP);
            classPropAccessor = new NonTerminal(Constants.CLASSPROPSETTER);
            unpackToStack = new NonTerminal(Constants.UNPACKTOSTACK);
            callParam = new NonTerminal(Constants.CALLPARAM);
            unpackList = new NonTerminal(Constants.UNPACKLIST);
            unpackStatement = new NonTerminal(Constants.UNPACKSTATEMENT);
            unpackItem = new NonTerminal(Constants.UNPACKITEM);
            localFunction = new NonTerminal(Constants.LOCALFUNCTION);
            functionCaptures = new NonTerminal(Constants.FUNCTIONCAPTURES);
            functionCapturesList = new NonTerminal(Constants.FUNCTIONCAPLIST);
            throwException = new NonTerminal(Constants.THROWEXCEPTION);
            shortHandArray = new NonTerminal(Constants.SHORTHANDARRAY);
            arrayAssignments = new NonTerminal(Constants.ARRAYASSIGNMENTS);
            arrayAssignment = new NonTerminal(Constants.ARRAYASSIGNMENT);
            shortHandStruct = new NonTerminal(Constants.SHORTHANDSTRUCT);
            structAssignments = new NonTerminal(Constants.STRUCTASSIGNMENTS);
            incDecField = new NonTerminal(Constants.INCDECFIELD);
            blockContent = new NonTerminal(Constants.BLOCKCONTENT);
            declarations = new NonTerminal(Constants.DECLARATIONS);
            declaration = new NonTerminal(Constants.DECLARATION);
            _return = new NonTerminal(Constants.RETURN);
            Root = rootDirectives;
        }
    }
}
